Questions fetched.
{
    "has_more": false,
    "items": [
        {
            "body": "<p>You can check the code of the function <a href=\"http://svn.python.org/projects/python/trunk/Lib/os.py\" rel=\"nofollow\">os.walk()</a>. It is a very good example of the use of <code>yield</code>.</p>\n",
            "question_id": 231767,
            "last_activity_date": 1444218868,
            "creation_date": 1444218868,
            "score": 0,
            "owner": {
                "user_id": 1579961,
                "profile_image": "https://www.gravatar.com/avatar/315ab4d7048f8f84306f149ab5c5f0d2?s=128&d=identicon&r=PG",
                "user_type": "registered",
                "reputation": 104,
                "link": "http://stackoverflow.com/users/1579961/nachouve",
                "display_name": "nachouve"
            },
            "is_accepted": false,
            "answer_id": 32991548
        },
        {
            "body": "<p>The <code>yield</code> keyword is reduced to two simple facts:</p>\n\n<ol>\n<li>If the compiler detects the <code>yield</code> keyword <em>anywhere</em> inside a function, that function no longer returns via the <code>return</code> statement. <strong><em>Instead</em></strong>, it <strong>immediately</strong> returns a <strong>lazy \"pending list\" object</strong> called a generator</li>\n<li>A generator is iterable. What is an <em>iterable</em>? It's anything like a <code>list</code> or <code>set</code> or <code>range</code> or dict-view, with a <em>built-in protocol for visiting each element in a certain order</em>.</li>\n</ol>\n\n<p>In a nutshell: <strong>a generator is a lazy, incrementally-pending list</strong>, and <strong><code>yield</code> statements allow you to use function notation to program the list values</strong> the generator should incrementally spit out.</p>\n\n<pre><code>generator = myYieldingFunction(...)\nx = list(generator)\n\n   generator\n       v\n[x[0], ..., ???]\n\n         generator\n             v\n[x[0], x[1], ..., ???]\n\n               generator\n                   v\n[x[0], x[1], x[2], ..., ???]\n\n                       StopIteration exception\n[x[0], x[1], x[2]]     done\n\nlist==[x[0], x[1], x[2]]\n</code></pre>\n\n<hr>\n\n<h2>Example</h2>\n\n<p>Let's define a function <code>makeRange</code> that's just like Python's <code>range</code>. Calling <code>makeRange(n)</code> RETURNS A GENERATOR:</p>\n\n<pre><code>def makeRange(n):\n    # return 0,1,2,...,n-1\n    i = 0\n    while i &lt; n:\n        yield i\n        i += 1\n\n&gt;&gt;&gt; makeRange(5)\n&lt;generator object makeRange at 0x19e4aa0&gt;\n</code></pre>\n\n<p>To force the generator to immediately return its pending values, you can pass it into <code>list()</code> (just like you could any iterable):</p>\n\n<pre><code>&gt;&gt;&gt; list(makeRange(5))\n[0, 1, 2, 3, 4]\n</code></pre>\n\n<hr>\n\n<h2>Comparing example to \"just returning a list\"</h2>\n\n<p>The above example can be thought of as merely creating a list which you append to and return:</p>\n\n<pre><code># list-version                   #  # generator-version\ndef makeRange(n):                #  def makeRange(n):\n    \"\"\"return [0,1,2,...,n-1]\"\"\" #~     \"\"\"return 0,1,2,...,n-1\"\"\"\n    TO_RETURN = []               #&gt;\n    i = 0                        #      i = 0\n    while i &lt; n:                 #      while i &lt; n:\n        TO_RETURN += [i]         #~         yield i\n        i += 1                   #      i += 1\n    return TO_RETURN             #&gt;\n\n&gt;&gt;&gt; makeRange(5)\n[0, 1, 2, 3, 4]\n</code></pre>\n\n<p>There is one major difference though; see the last section.</p>\n\n<hr>\n\n<h2>How you might use generators</h2>\n\n<p>An iterable is the last part of a list comprehension, and all generators are iterable, so they're often used like so:</p>\n\n<pre><code>#                   _ITERABLE_\n&gt;&gt;&gt; [x+10 for x in makeRange(5)]\n[10, 11, 12, 13, 14]\n</code></pre>\n\n<p>To get a better feel for generators, you can play around with the <code>itertools</code> module (be sure to use <code>chain.from_iterable</code> rather than <code>chain</code> when warranted). For example, you might even use generators to implement infinitely-long lazy lists like <code>itertools.count()</code>. You could implement your own <code>def enumerate(iterable): zip(count(), iterable)</code>, or alternatively do so with the <code>yield</code> keyword in a while-loop.</p>\n\n<p>Please note: generators can actually be used for many more things, such as <a href=\"http://www.dabeaz.com/coroutines/index.html\">implementing coroutines</a> or non-deterministic programming or other elegant things. However, the \"lazy lists\" viewpoint I present here is the most common use you will find.</p>\n\n<hr>\n\n<h2>Behind the scenes</h2>\n\n<p>This is how the \"Python iteration protocol\" works. That is, what is going on when you do <code>list(makeRange(5))</code>. This is what I describe earlier as a \"lazy, incremental list\".</p>\n\n<pre><code>&gt;&gt;&gt; x=iter(range(5))\n&gt;&gt;&gt; next(x)\n0\n&gt;&gt;&gt; next(x)\n1\n&gt;&gt;&gt; next(x)\n2\n&gt;&gt;&gt; next(x)\n3\n&gt;&gt;&gt; next(x)\n4\n&gt;&gt;&gt; next(x)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nStopIteration\n</code></pre>\n\n<p>The built-in function <code>next()</code> just calls the objects <code>.next()</code> function, which is a part of the \"iteration protocol\" and is found on all iterators. You can manually use the <code>next()</code> function (and other parts of the iteration protocol) to implement fancy things, usually at the expense of readability, so try to avoid doing that...</p>\n\n<hr>\n\n<h2>Minutiae</h2>\n\n<p>Normally, most people would not care about the following distinctions and probably want to stop reading here.</p>\n\n<p>In Python-speak, an <em>iterable</em> is any object which \"understands the concept of a for-loop\" like a list <code>[1,2,3]</code>, and an <em>iterator</em> is a specific instance of the requested for-loop like <code>[1,2,3].__iter__()</code>. A <em>generator</em> is exactly the same as any iterator, except for the way it was written (with function syntax).</p>\n\n<p>When you request an iterator from a list, it creates a new iterator. However, when you request an iterator from an iterator (which you would rarely do), it just gives you a copy of itself.</p>\n\n<p>Thus, in the unlikely event that you are failing to do something like this...</p>\n\n<pre><code>&gt; x = myRange(5)\n&gt; list(x)\n[0, 1, 2, 3, 4]\n&gt; list(x)\n[]\n</code></pre>\n\n<p>... then remember that a generator is an <em>iterator</em>; that is, it is one-time-use. If you want to reuse it, you should call <code>myRange(...)</code> again. If you need to use the result twice, convert the result to a list and store it in a variable <code>x = list(myRange(5))</code>. Those who absolutely need to clone a generator (for example, who are doing terrifyingly hackish metaprogramming) can use <a href=\"https://docs.python.org/2/library/itertools.html#itertools.tee\"><code>itertools.tee</code></a> if absolutely necessary, since the copyable iterator Python <a href=\"http://en.wikipedia.org/wiki/Python_Enhancement_Proposal#Development\">PEP</a> standards proposal has been deferred.</p>\n",
            "question_id": 231767,
            "last_activity_date": 1442696907,
            "creation_date": 1308465238,
            "score": 124,
            "owner": {
                "user_id": 711085,
                "profile_image": "https://www.gravatar.com/avatar/fabf3436107ffee76255957a7732d0f1?s=128&d=identicon&r=PG",
                "user_type": "registered",
                "reputation": 33389,
                "link": "http://stackoverflow.com/users/711085/ninjagecko",
                "display_name": "ninjagecko"
            },
            "is_accepted": false,
            "last_edit_date": 1442696907,
            "answer_id": 6400990
        },
        {
            "body": "<p><strong>Yield is Object</strong></p>\n\n<p>a <code>return</code> in function will return single value.</p>\n\n<p>if you want <strong>function to return huge set of values</strong> use <code>Yield</code></p>\n\n<p>more importantly <code>Yield</code> is a <strong>barrier</strong> </p>\n\n<blockquote>\n  <p>like Barrier in Cuda Language. will not transfer control until it gets\n  completed.</p>\n</blockquote>\n\n<p>i.e</p>\n\n<p>it will run the code in your function from the beginning until it hits <code>yield</code>. then it\u2019ll return the first value of the loop. \nThen, each other call will run the loop you have written in the function one more time, and return the next value, until there is no value to return.</p>\n",
            "question_id": 231767,
            "last_activity_date": 1441111339,
            "creation_date": 1441111339,
            "score": 0,
            "owner": {
                "user_id": 2046817,
                "profile_image": "https://i.stack.imgur.com/GWBHx.jpg?s=128&g=1",
                "user_type": "registered",
                "reputation": 421,
                "link": "http://stackoverflow.com/users/2046817/lukyboy-ku",
                "accept_rate": 100,
                "display_name": "LukyBoy -KU"
            },
            "is_accepted": false,
            "answer_id": 32331953
        },
        {
            "body": "<blockquote>\n  <p><strong>What does the <code>yield</code> keyword do in Python?</strong></p>\n</blockquote>\n\n<p><strong>Answer Outline/Summary</strong></p>\n\n<ul>\n<li><strong><code>yield</code></strong> makes a function definition that <strong>returns a generator.</strong></li>\n<li>Generators implement the <strong>iterator protocol</strong>, so you can iterate over them.</li>\n<li>The generator can also be <strong>sent information</strong>, making it conceptually a <strong>coroutine</strong>.</li>\n<li>In Python 3, you can <strong>delegate</strong> from one generator to another in both directions with <strong><code>yield from</code></strong>.</li>\n</ul>\n\n<p><strong>Generators:</strong></p>\n\n<p><strong><code>yield</code></strong> is only legal inside of a function definition, and <strong>the inclusion of <code>yield</code> in a function definition makes it return a generator.</strong></p>\n\n<p>The idea for generators comes from other languages (see footnote 1) with varying implementations. In Python's Generators, the execution of the code is <a href=\"https://docs.python.org/3.5/glossary.html#term-generator-iterator\">frozen</a> at the point of the yield. When the generator is called (methods are discussed below) execution resumes and then freezes at the next yield.</p>\n\n<p><code>yield</code> provides an \neasy way of <a href=\"https://docs.python.org/2/library/stdtypes.html#generator-types\">implementing the iterator protocol</a>, defined by the following two methods: \n<code>__iter__</code> and <code>next</code> (Python 2) or <code>__next__</code> (Python 3).  Both of those methods\nmake an object an iterator that you could type-check with the <code>Iterator</code> Abstract Base \nClass from the <code>collections</code> module.</p>\n\n<pre><code>&gt;&gt;&gt; def gen():\n...     yield 'I am'\n...     yield 'a generator!'\n... \n&gt;&gt;&gt; g = gen()\n&gt;&gt;&gt; hasattr(g, '__iter__')\nTrue\n&gt;&gt;&gt; hasattr(g, 'next')\nTrue \n&gt;&gt;&gt; import collections \n&gt;&gt;&gt; isinstance(g, collections.Iterator)\nTrue   \n</code></pre>\n\n<p>A feature of an <code>Iterator</code> <a href=\"https://docs.python.org/2/glossary.html#term-iterator\">is that once exhausted</a>, you can't reuse or reset it:</p>\n\n<pre><code>&gt;&gt;&gt; list(g)\n['I am', 'a generator!']\n&gt;&gt;&gt; list(g)\n[]\n</code></pre>\n\n<p>You'll have to make another if you want to use its functionality again (see footnote 2):</p>\n\n<pre><code>&gt;&gt;&gt; list(gen())\n['I am', 'a generator!']\n</code></pre>\n\n<p>One can yield data programmatically, for example:</p>\n\n<pre><code>def gen(an_iterable):\n    for item in an_iterable:\n        yield item\n</code></pre>\n\n<p>The above simple generator is also equivalent to the below - as of Python 3.3 (and not available in Python 2), you can use <a href=\"https://www.python.org/dev/peps/pep-0380/\"><code>yield from</code></a>:</p>\n\n<pre><code>def gen(an_iterable):\n    yield from an_iterable\n</code></pre>\n\n<p>However, <code>yield from</code> also allows for delegation to subgenerators, \nwhich will be explained in the following section on cooperative delegation with sub-coroutines.</p>\n\n<p><strong>Coroutines:</strong></p>\n\n<p><code>yield</code> forms an expression that allows data to be sent into the generator (see footnote 3)</p>\n\n<p>Here is an example, take note of the <code>received</code> variable, which will point to the data that is sent to the generator:</p>\n\n<pre><code>def bank_account(deposited, interest_rate):\n    while True:\n        calculated_interest = interest_rate * deposited \n        received = yield calculated_interest\n        if received:\n            deposited += received\n\n\n&gt;&gt;&gt; my_account = bank_account(1000, .05)\n</code></pre>\n\n<p>First, we must queue up the generator with the builtin function, <a href=\"https://docs.python.org/2/library/functions.html#next\"><code>next</code></a>. It will \ncall the appropriate <code>next</code> or <code>__next__</code> method, depending on the version of\nPython you are using:</p>\n\n<pre><code>&gt;&gt;&gt; first_year_interest = next(my_account)\n&gt;&gt;&gt; first_year_interest\n50.0\n</code></pre>\n\n<p>And now we can send data into the generator. (<a href=\"https://www.python.org/dev/peps/pep-0342/\">Sending <code>None</code> is \nthe same as calling <code>next</code></a>.) :</p>\n\n<pre><code>&gt;&gt;&gt; next_year_interest = my_account.send(first_year_interest + 1000)\n&gt;&gt;&gt; next_year_interest\n102.5\n</code></pre>\n\n<p><strong>Cooperative Delegation to Sub-Coroutine with <code>yield from</code></strong></p>\n\n<p>Now, recall that <code>yield from</code> is available in Python 3. This allows us to delegate\ncoroutines to a subcoroutine:</p>\n\n<pre><code>def money_manager(expected_rate):\n    under_management = yield     # must receive deposited value\n    while True:\n        try:\n            additional_investment = yield expected_rate * under_management \n            if additional_investment:\n                under_management += additional_investment\n        except GeneratorExit:\n            '''TODO: write function to send unclaimed funds to state'''\n        finally:\n            '''TODO: write function to mail tax info to client'''\n\n\ndef investment_account(deposited, manager):\n    '''very simple model of an investment account that delegates to a manager'''\n    next(manager) # must queue up manager\n    manager.send(deposited)\n    while True:\n        try:\n            yield from manager\n        except GeneratorExit:\n            return manager.close()\n</code></pre>\n\n<p>And now we can delegate functionality to a sub-generator and it can be used\nby a generator just as above:</p>\n\n<pre><code>&gt;&gt;&gt; my_manager = money_manager(.06)\n&gt;&gt;&gt; my_account = investment_account(1000, my_manager)\n&gt;&gt;&gt; first_year_return = next(my_account)\n&gt;&gt;&gt; first_year_return\n60.0\n&gt;&gt;&gt; next_year_return = my_account.send(first_year_return + 1000)\n&gt;&gt;&gt; next_year_return\n123.6\n</code></pre>\n\n<p><strong>Other Methods: close and throw</strong></p>\n\n<p>The <code>close</code> method raises <code>GeneratorExit</code> at the point the function \nexecution was frozen. This will also be called by <code>__del__</code> so you \ncan put any cleanup code where you handle the <code>GeneratorExit</code>:</p>\n\n<pre><code>&gt;&gt;&gt; my_account.close()\n</code></pre>\n\n<p>You can also throw an exception which can be handled in the generator\nor propagated back to the user:</p>\n\n<pre><code>&gt;&gt;&gt; import sys\n&gt;&gt;&gt; try:\n...     raise ValueError\n... except:\n...     my_manager.throw(*sys.exc_info())\n... \nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 4, in &lt;module&gt;\n  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\nValueError\n</code></pre>\n\n<p><strong>Conclusion</strong></p>\n\n<p>I believe I have covered all aspects of the following question:</p>\n\n<blockquote>\n  <p><strong>What does the <code>yield</code> keyword do in Python?</strong></p>\n</blockquote>\n\n<p>It turns out that <code>yield</code> does a lot. I'm sure I could add even more \nthorough examples to this. If you want more or have some constructive criticism, let me know by commenting\nbelow.</p>\n\n<hr>\n\n<p>Appendix:</p>\n\n<p><strong>Critique of the Top/Accepted Answer</strong></p>\n\n<ul>\n<li>It is confused on what makes an <strong>iterable</strong>, just using a list as an example. See my references above, but in summary: an iterable has an <code>__iter__</code> method returning an <strong>iterator</strong>. An <strong>iterator</strong> provides a <code>.next</code> (Python 2 or <code>.__next__</code> (Python 3) method, which is implicitly called by <code>for</code> loops until it raises <code>StopIteration</code>, and once it does, it will continue to do so.</li>\n<li>It then uses a generator expression to describe what a generator is. Since a generator is simply a convenient way to create an <strong>iterator</strong>, it only confuses the matter, and we still have not yet gotten to the <code>yield</code> part.</li>\n<li>In <strong>Controlling a generator exhaustion</strong> he calls the <code>.next</code> method, when instead he should use the builtin function, <code>next</code>. It would be an appropriate layer of indirection, because his code does not work in Python 3.</li>\n<li>Itertools? This was not relevant to what <code>yield</code> does at all.</li>\n<li>No discussion of the methods that <code>yield</code> provides along with the new functionality <code>yield from</code> in Python 3. <strong>The top/accepted answer is a very incomplete answer.</strong></li>\n</ul>\n\n<p>Footnotes</p>\n\n<ol>\n<li><p><sub>The languages CLU, Sather, and Icon were referenced in the proposal\nto introduce the concept of generators to Python. The general idea is\nthat a function can maintain internal state and yield intermediate \ndata points on demand by the user. This promised to be <a href=\"https://www.python.org/dev/peps/pep-0255/\">superior in performance \nto other approaches, including Python threading</a>, which isn't even available on some systems.</sub></p></li>\n<li><p><sub> This means, for example, that <code>xrange</code> objects (<code>range</code> in Python 3) aren't <code>Iterator</code>s, even though they are iterable, because they can be reused. Like lists, their <code>__iter__</code> methods return iterator objects.</sub></p></li>\n<li><p><sub> \n<code>yield</code> was originally introduced as a statement, meaning that it \ncould only appear at the beginning of a line in a code block. \nNow <code>yield</code> creates a yield expression. \n<a href=\"https://docs.python.org/2/reference/simple_stmts.html#grammar-token-yield_stmt\">https://docs.python.org/2/reference/simple_stmts.html#grammar-token-yield_stmt</a> \nThis change was <a href=\"https://www.python.org/dev/peps/pep-0342/\">proposed</a> to allow a user to send data into the generator just as\none might receive it. To send data, one must be able to assign it to something, and\nfor that, a statement just won't work.</sub></p></li>\n</ol>\n",
            "question_id": 231767,
            "last_activity_date": 1438359375,
            "creation_date": 1435212671,
            "score": 29,
            "owner": {
                "user_id": 541136,
                "profile_image": "https://i.stack.imgur.com/KaKAY.jpg?s=128&g=1",
                "user_type": "registered",
                "reputation": 26351,
                "link": "http://stackoverflow.com/users/541136/aaron-hall",
                "accept_rate": 87,
                "display_name": "Aaron Hall"
            },
            "is_accepted": false,
            "last_edit_date": 1438359375,
            "answer_id": 31042491
        },
        {
            "body": "<p>Like every answer suggests, yield is used for creating a sequence generator. It's used for generating some sequence dynamically. Eg. while reading a file line by line on a network, you can use the yield function as follows :-</p>\n\n<pre><code>def getNextLines():\n   while con.isOpen():\n       yield con.read()\n</code></pre>\n\n<p>You can use it in your code as follows :</p>\n\n<pre><code>for line in getNextLines():\n    doSomeThing(line)\n</code></pre>\n\n<p><strong><em>Execution Control Transfer gotcha</em></strong></p>\n\n<p>The execution control will be transferred from getNextLines() to the for loop, when yield is executed. Thus every time getNextLines() is invoked, execution begin from the point where it was paused last time.</p>\n\n<p>Thus in short, a function with the following code</p>\n\n<pre><code>def simpleYield():\n    yield \"first time\"\n    yield \"second time\"\n    yield \"third time\"\n    yield \"Now some useful value {}\".format(12)\n\nfor i in simpleYield():\n    print i\n</code></pre>\n\n<p>will print </p>\n\n<pre><code>\"first time\"\n\"second time\"\n\"third time\"\n\"Now some useful value 12\"\n</code></pre>\n\n<p>Hope, it helps you.</p>\n",
            "question_id": 231767,
            "last_activity_date": 1438150285,
            "creation_date": 1438150285,
            "score": 0,
            "owner": {
                "user_id": 2393267,
                "profile_image": "https://www.gravatar.com/avatar/16f4194ca5787bda3fe6f02d78f37d1c?s=128&d=identicon&r=PG",
                "user_type": "registered",
                "reputation": 46,
                "link": "http://stackoverflow.com/users/2393267/user2393267",
                "accept_rate": 100,
                "display_name": "user2393267"
            },
            "is_accepted": false,
            "answer_id": 31692481
        },
        {
            "body": "<p>To understand what <code>yield</code> does, you must understand what are <em>generators</em>. And before generators come <em>iterables</em>.</p>\n\n<h2>Iterables</h2>\n\n<p>When you create a list, you can read its items one by one. Reading its items one by one is called iteration:</p>\n\n<pre><code>&gt;&gt;&gt; mylist = [1, 2, 3]\n&gt;&gt;&gt; for i in mylist:\n...    print(i)\n1\n2\n3\n</code></pre>\n\n<p><code>mylist</code> is an <em>iterable</em>. When you use a list comprehension, you create a list, and so an iterable:</p>\n\n<pre><code>&gt;&gt;&gt; mylist = [x*x for x in range(3)]\n&gt;&gt;&gt; for i in mylist:\n...    print(i)\n0\n1\n4\n</code></pre>\n\n<p>Everything you can use <code>\"for... in...\"</code> on is an iterable: <code>lists</code>, <code>strings</code>, files...</p>\n\n<p>These iterables are handy because you can read them as much as you wish, but you store all the values in memory and this is not always what you want when you have a lot of values.</p>\n\n<h2>Generators</h2>\n\n<p>Generators are iterators, but <strong>you can only iterate over them once</strong>. It's because they do not store all the values in memory, <strong>they generate the values on the fly</strong>:</p>\n\n<pre><code>&gt;&gt;&gt; mygenerator = (x*x for x in range(3))\n&gt;&gt;&gt; for i in mygenerator:\n...    print(i)\n0\n1\n4\n</code></pre>\n\n<p>It is just the same except you used <code>()</code> instead of <code>[]</code>. BUT, you can not perform <code>for i in mygenerator</code> a second time since generators can only be used once: they calculate 0, then forget about it and calculate 1, and end calculating 4, one by one.</p>\n\n<h2>Yield</h2>\n\n<p><code>Yield</code> is a keyword that is used like <code>return</code>, except the function will return a generator.</p>\n\n<pre><code>&gt;&gt;&gt; def createGenerator():\n...    mylist = range(3)\n...    for i in mylist:\n...        yield i*i\n...\n&gt;&gt;&gt; mygenerator = createGenerator() # create a generator\n&gt;&gt;&gt; print(mygenerator) # mygenerator is an object!\n&lt;generator object createGenerator at 0xb7555c34&gt;\n&gt;&gt;&gt; for i in mygenerator:\n...     print(i)\n0\n1\n4\n</code></pre>\n\n<p>Here it's a useless example, but it's handy when you know your function will return a huge set of values that you will only need to read once.</p>\n\n<p>To master <code>yield</code>, you must understand that <strong>when you call the function, the code you have written in the function body does not run.</strong> The function only returns the generator object, this is a bit tricky :-)</p>\n\n<p>Then, your code will be run each time the <code>for</code> uses the generator.</p>\n\n<p>Now the hard part:</p>\n\n<p>The first time the <code>for</code> calls the generator object created from your function, it will run the code in your function from the beginning until it hits <code>yield</code>, then it'll return the first value of the loop. Then, each other call will run the loop you have written in the function one more time, and return the next value, until there is no value to return.</p>\n\n<p>The generator is considered empty once the function runs but does not hit yield anymore. It can be because the loop had come to an end, or because you do not satisfy a <code>\"if/else\"</code> anymore.</p>\n\n<h2>Your code explained</h2>\n\n<p>Generator:</p>\n\n<pre><code># Here you create the method of the node object that will return the generator\ndef node._get_child_candidates(self, distance, min_dist, max_dist):\n\n  # Here is the code that will be called each time you use the generator object:\n\n  # If there is still a child of the node object on its left\n  # AND if distance is ok, return the next child\n  if self._leftchild and distance - max_dist &lt; self._median:\n      yield self._leftchild\n\n  # If there is still a child of the node object on its right\n  # AND if distance is ok, return the next child\n  if self._rightchild and distance + max_dist &gt;= self._median:\n      yield self._rightchild\n\n  # If the function arrives here, the generator will be considered empty\n  # there is no more than two values: the left and the right children\n</code></pre>\n\n<p>Caller:</p>\n\n<pre><code># Create an empty list and a list with the current object reference\nresult, candidates = list(), [self]\n\n# Loop on candidates (they contain only one element at the beginning)\nwhile candidates:\n\n    # Get the last candidate and remove it from the list\n    node = candidates.pop()\n\n    # Get the distance between obj and the candidate\n    distance = node._get_dist(obj)\n\n    # If distance is ok, then you can fill the result\n    if distance &lt;= max_dist and distance &gt;= min_dist:\n        result.extend(node._values)\n\n    # Add the children of the candidate in the candidates list\n    # so the loop will keep running until it will have looked\n    # at all the children of the children of the children, etc. of the candidate\n    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))\n\nreturn result\n</code></pre>\n\n<p>This code contains several smart parts:</p>\n\n<ul>\n<li><p>The loop iterates on a list but the list expands while the loop is being iterated :-) It's a concise way to go through all these nested data even if it's a bit dangerous since you can end up with an infinite loop. In this case, <code>candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))</code> exhausts all the values of the generator, but <code>while</code> keeps creating new generator objects which will produce different values from the previous ones since it's not applied on the same node.</p></li>\n<li><p>The <code>extend()</code> method is a list object method that expects an iterable and adds its values to the list.</p></li>\n</ul>\n\n<p>Usually we pass a list to it:</p>\n\n<pre><code>&gt;&gt;&gt; a = [1, 2]\n&gt;&gt;&gt; b = [3, 4]\n&gt;&gt;&gt; a.extend(b)\n&gt;&gt;&gt; print(a)\n[1, 2, 3, 4]\n</code></pre>\n\n<p>But in your code it gets a generator, which is good because:</p>\n\n<ol>\n<li>You don't need to read the values twice.</li>\n<li>You can have a lot of children and you don't want them all stored in memory.</li>\n</ol>\n\n<p>And it works because Python does not care if the argument of a method is a list or not. Python expects iterables so it will work with strings, lists, tuples and generators! This is called duck typing and is one of the reason why Python is so cool. But this is another story, for another question...</p>\n\n<p>You can stop here, or read a little bit to see a advanced use of generator:</p>\n\n<h2>Controlling a generator exhaustion</h2>\n\n<pre><code>&gt;&gt;&gt; class Bank(): # let's create a bank, building ATMs\n...    crisis = False\n...    def create_atm(self):\n...        while not self.crisis:\n...            yield \"$100\"\n&gt;&gt;&gt; hsbc = Bank() # when everything's ok the ATM gives you as much as you want\n&gt;&gt;&gt; corner_street_atm = hsbc.create_atm()\n&gt;&gt;&gt; print(corner_street_atm.next())\n$100\n&gt;&gt;&gt; print(corner_street_atm.next())\n$100\n&gt;&gt;&gt; print([corner_street_atm.next() for cash in range(5)])\n['$100', '$100', '$100', '$100', '$100']\n&gt;&gt;&gt; hsbc.crisis = True # crisis is coming, no more money!\n&gt;&gt;&gt; print(corner_street_atm.next())\n&lt;type 'exceptions.StopIteration'&gt;\n&gt;&gt;&gt; wall_street_atm = hsbc.create_atm() # it's even true for new ATMs\n&gt;&gt;&gt; print(wall_street_atm.next())\n&lt;type 'exceptions.StopIteration'&gt;\n&gt;&gt;&gt; hsbc.crisis = False # trouble is, even post-crisis the ATM remains empty\n&gt;&gt;&gt; print(corner_street_atm.next())\n&lt;type 'exceptions.StopIteration'&gt;\n&gt;&gt;&gt; brand_new_atm = hsbc.create_atm() # build a new one to get back in business\n&gt;&gt;&gt; for cash in brand_new_atm:\n...    print cash\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n...\n</code></pre>\n\n<p>It can be useful for various things like controlling access to a resource.</p>\n\n<h2>Itertools, your best friend</h2>\n\n<p>The itertools module contains special functions to manipulate iterables. Ever wish to duplicate a generator?\nChain two generators? Group values in a nested list with a one liner? <code>Map / Zip</code> without creating another list?</p>\n\n<p>Then just <code>import itertools</code>.</p>\n\n<p>An example? Let's see the possible orders of arrival for a 4 horse race:</p>\n\n<pre><code>&gt;&gt;&gt; horses = [1, 2, 3, 4]\n&gt;&gt;&gt; races = itertools.permutations(horses)\n&gt;&gt;&gt; print(races)\n&lt;itertools.permutations object at 0xb754f1dc&gt;\n&gt;&gt;&gt; print(list(itertools.permutations(horses)))\n[(1, 2, 3, 4),\n (1, 2, 4, 3),\n (1, 3, 2, 4),\n (1, 3, 4, 2),\n (1, 4, 2, 3),\n (1, 4, 3, 2),\n (2, 1, 3, 4),\n (2, 1, 4, 3),\n (2, 3, 1, 4),\n (2, 3, 4, 1),\n (2, 4, 1, 3),\n (2, 4, 3, 1),\n (3, 1, 2, 4),\n (3, 1, 4, 2),\n (3, 2, 1, 4),\n (3, 2, 4, 1),\n (3, 4, 1, 2),\n (3, 4, 2, 1),\n (4, 1, 2, 3),\n (4, 1, 3, 2),\n (4, 2, 1, 3),\n (4, 2, 3, 1),\n (4, 3, 1, 2),\n (4, 3, 2, 1)]\n</code></pre>\n\n<h2>Understanding the inner mechanisms of iteration</h2>\n\n<p>Iteration is a process implying iterables (implementing the <code>__iter__()</code> method) and iterators (implementing the <code>__next__()</code> method).\nIterables are any objects you can get an iterator from. Iterators are objects that let you iterate on iterables.</p>\n\n<p>More about it in this article about <a href=\"http://effbot.org/zone/python-for-statement.htm\">how does the for loop work</a>.</p>\n",
            "question_id": 231767,
            "last_activity_date": 1436909023,
            "creation_date": 1224802124,
            "score": 6320,
            "owner": {
                "user_id": 9951,
                "profile_image": "https://www.gravatar.com/avatar/1449ec95d8c114dbca53136cc8194b61?s=128&d=identicon&r=PG&f=1",
                "user_type": "registered",
                "reputation": 204251,
                "link": "http://stackoverflow.com/users/9951/e-satis",
                "accept_rate": 79,
                "display_name": "e-satis"
            },
            "is_accepted": true,
            "last_edit_date": 1436909023,
            "answer_id": 231855
        },
        {
            "body": "<p>There is another yield use and meaning (since python 3.3):</p>\n\n<pre><code>yield from &lt;expr&gt;\n</code></pre>\n\n<p><a href=\"http://legacy.python.org/dev/peps/pep-0380/\" rel=\"nofollow\">http://legacy.python.org/dev/peps/pep-0380/</a></p>\n\n<blockquote>\n  <p>A syntax is proposed for a generator to delegate part of its operations to another generator. This allows a section of code containing 'yield' to be factored out and placed in another generator. Additionally, the subgenerator is allowed to return with a value, and the value is made available to the delegating generator.</p>\n  \n  <p>The new syntax also opens up some opportunities for optimisation when one generator re-yields values produced by another.</p>\n</blockquote>\n\n<p>moreover <a href=\"https://www.python.org/dev/peps/pep-0492/\" rel=\"nofollow\">https://www.python.org/dev/peps/pep-0492/</a> will introduce (since python 3.5):</p>\n\n<pre><code>async def new_coroutine(data):\n   ...\n   await blocking_action()\n</code></pre>\n\n<p>to avoid confuse coroutines with regular generator (today <code>yield</code> is used in both).</p>\n",
            "question_id": 231767,
            "last_activity_date": 1435439055,
            "creation_date": 1406236529,
            "score": 17,
            "owner": {
                "user_id": 1416144,
                "profile_image": "https://www.gravatar.com/avatar/bab2906fe97538ebda3121f8e9c04807?s=128&d=identicon&r=PG",
                "user_type": "registered",
                "reputation": 418,
                "link": "http://stackoverflow.com/users/1416144/ups",
                "accept_rate": 52,
                "display_name": "ups"
            },
            "is_accepted": false,
            "last_edit_date": 1435439055,
            "answer_id": 24944096
        },
        {
            "body": "<p><code>yield</code> is like a return element for a function. The difference is, that the <code>yield</code> element turns a function into a generator. A generator behaves just like a function until something is 'yielded'. The generator stops until it is next called, and continues from exactly the same point as it started. You can get a sequence of all the 'yielded' values in one, by calling <code>list(generator())</code>.</p>\n",
            "question_id": 231767,
            "last_activity_date": 1432102772,
            "creation_date": 1432102772,
            "score": 7,
            "owner": {
                "user_id": 4884103,
                "profile_image": "https://www.gravatar.com/avatar/d816ef3e01a9c231b01ca20b271f1920?s=128&d=identicon&r=PG&f=1",
                "user_type": "registered",
                "reputation": 160,
                "link": "http://stackoverflow.com/users/4884103/an-epic-person",
                "display_name": "An Epic Person"
            },
            "is_accepted": false,
            "answer_id": 30341713
        },
        {
            "body": "<p>yield is just like return.  It returns whatever you tell it to.  The only difference is that the next time you call the function, execution starts from the last call to the yield statement.</p>\n\n<p>In the case of your code, the function <code>get_child_candidates</code> is acting like an iterator so that when you extend your list, it adds one element at a time to the new list.</p>\n\n<p>list.extend calls an iterator until it's exhausted.  In the case of the code sample you posted, it would be much clearer to just return a tuple and append that to the list.</p>\n",
            "question_id": 231767,
            "last_activity_date": 1429298969,
            "creation_date": 1224800643,
            "score": 71,
            "owner": {
                "user_id": 8458,
                "profile_image": "https://www.gravatar.com/avatar/545f75612aa60a8acc211cc86348eb16?s=128&d=identicon&r=PG",
                "user_type": "registered",
                "reputation": 8796,
                "link": "http://stackoverflow.com/users/8458/douglas-mayle",
                "accept_rate": 89,
                "display_name": "Douglas Mayle"
            },
            "is_accepted": false,
            "last_edit_date": 1429298969,
            "answer_id": 231778
        },
        {
            "body": "<p>There is one type of answer that I don't feel has been given yet, among the many great answers that describe how to use generators.  Here is the PL theory answer:</p>\n\n<p>The <code>yield</code> statement in python returns a generator.  A generator in python is a function that returns <i>continuations</i> (and specifically a type of coroutine, but continuations represent the more general mechanism to understand what is going on).</p>\n\n<p>Continuations in programming languages theory are a much more fundamental kind of computation, but they are not often used because they are extremely hard to reason about and also very difficult to implement.  But the idea of what a continuation is, is straightforward: it is the state of a computation that has not yet finished. In this state are saved the current values of variables and the operations that have yet to be performed, and so on. Then at some point later in the program the continuation can be invoked, such that the program's variables are reset to that state and the operations that were saved are carried out.</p>\n\n<p>Continuations, in this more general form, can be implemented in two ways. In the <code>call/cc</code> way, the program's stack is literally saved and then when the continuation is invoked, the stack is restored.</p>\n\n<p>In continuation passing style (CPS), continuations are just normal functions (only in languages where functions are first class) which the programmer explicitly manages and passes around to subroutines. In this style, program state is represented by closures (and the variables that happen to be encoded in them) rather than variables that reside somewhere on the stack. Functions that manage control flow accept continuation as arguments (in some variations of CPS, functions may accept multiple continuations) and manipulate control flow by invoking them by simply calling them and returning afterwards. A very simple example of continuation passing style is as follows:</p>\n\n<pre><code>def save_file(filename):\n  def write_file_continuation():\n    write_stuff_to_file(filename)\n\n  check_if_file_exists_and_user_wants_to_overwrite( write_file_continuation )\n</code></pre>\n\n<p>In this (very simplistic) example, the programmer saves the operation of actually writing the file into a continuation (which can potentially be a very complex operation with many details to write out), and then passes that continuation (i.e, as a first-class closure) to another operator which does some more processing, and then calls it if necessary. (I use this design pattern a lot in actual GUI programming, either because it saves me lines of code or, more importantly, to wait for GUI events and then execute saved continuations repeatedly)</p>\n\n<p>The rest of this post will, without loss of generality, conceptualize continuations as CPS, because it is a hell of a lot easier to understand and read.</p>\n\n<p><br></p>\n\n<p>Now let's talk about generators in python. Generators are a specific subtype of continuation. Whereas <strong>continuations are able in general to save the state of a <em>computation</em></strong> (i.e., the program's call stack), <strong>generators are only able to save the state of iteration over an <em>iterator</em></strong>. Although, this definition is slightly misleading for certain use cases of generators. For instance:</p>\n\n<pre><code>def f():\n  while True:\n    yield 4\n</code></pre>\n\n<p>This is clearly a reasonable iterable whose behavior is well defined -- each time the generator iterates over it, it returns 4 (and does so forever). But it isn't probably the prototypical type of iterable that comes to mind when thinking of iterators (i.e., <code>for x in collection: do_something(x)</code>). This example illustrates the power of generators: if anything is an iterator, a generator can save the state of its iteration.</p>\n\n<p>To reiterate: Continuations can save the state of a program's stack and generators can save the state of iteration. This means that continuations are more a lot powerful than generators, but also that generators are a lot, lot easier. They are easier for the language designer to implement, and they are easier for the programmer to use (if you have some time to burn, try to read and understand <a href=\"http://www.madore.org/~david/computers/callcc.html\">this page about continuations and call/cc</a>).</p>\n\n<p>But you could easily implement (and conceptualize) generators as a simple, specific case of continuation passing style: </p>\n\n<p>Whenever <code>yield</code> is called, it tells the function to return a continuation.  When the function is called again, it starts from wherever it left off. So, in pseudo-pseudocode  (i.e., not pseudocode but not code) the generator's <code>next</code> method is basically as follows: </p>\n\n<pre><code>class Generator():\n  def __init__(self,iterable,generatorfun):\n    self.next_continuation = lambda:generatorfun(iterable)\n\n  def next(self):\n    value, next_continuation = self.next_continuation()\n    self.next_continuation = next_continuation\n    return value\n</code></pre>\n\n<p>where <code>yield</code> keyword is actually syntactic sugar for the real generator function, basically something like:</p>\n\n<pre><code>def generatorfun(iterable):\n  if len(iterable) == 0:\n    raise StopIteration\n  else:\n    return (iterable[0], lambda:generatorfun(iterable[1:]))\n</code></pre>\n\n<p>Remember that this is just pseudocode and the actual implementation of generators in python is more complex. But as an exercise to understand what is going on, try to use continuation passing style to implement generator objects without use of the <code>yield</code> keyword.</p>\n",
            "question_id": 231767,
            "last_activity_date": 1418075970,
            "creation_date": 1365087379,
            "score": 39,
            "owner": {
                "user_id": 2040716,
                "profile_image": "https://www.gravatar.com/avatar/2f3c22034b5114aa94cd4505e000f6c7?s=128&d=identicon&r=PG",
                "user_type": "registered",
                "reputation": 1880,
                "link": "http://stackoverflow.com/users/2040716/aestrivex",
                "accept_rate": 77,
                "display_name": "aestrivex"
            },
            "is_accepted": false,
            "last_edit_date": 1418075970,
            "answer_id": 15814755
        },
        {
            "body": "<h2>Shortcut to <a href=\"http://en.wikipedia.org/wiki/Grok\">Grokking</a> <code>yield</code></h2>\n\n<p>When you see a function with <code>yield</code> statements, apply this easy trick to understand what will happen:</p>\n\n<ol>\n<li>Insert a line <code>result = []</code> at the start of the function.</li>\n<li>Replace each <code>yield expr</code> with <code>result.append(expr)</code>.</li>\n<li>Insert a line <code>return result</code> at the bottom of the function.</li>\n<li>Yay - no more <code>yield</code> statements! Read and figure out code.</li>\n<li>Compare function to original definition.</li>\n</ol>\n\n<p>This trick may give you an idea of the logic behind the function, but what actually happens with <code>yield</code> is significantly different that what happens in the list based approach. In many cases the yield approach will be a lot more memory efficient and faster too. In other cases this trick will get you stuck in an infinite loop, even though the original function works just fine. Read on to learn more...</p>\n\n<h2>Don't confuse your Iterables, Iterators and Generators</h2>\n\n<p>First, the <strong>iterator protocol</strong> - when you write</p>\n\n<pre><code>for x in mylist:\n    ...loop body...\n</code></pre>\n\n<p>Python performs the following two steps:</p>\n\n<ol>\n<li><p>Gets an iterator for <code>mylist</code>:</p>\n\n<p>Call <code>iter(mylist)</code> -> this returns an object with a <code>next()</code> method (or <code>__next__()</code> in Python 3).</p>\n\n<p>[This is the step most people forget to tell you about]</p></li>\n<li><p>Uses the iterator to loop over items:</p>\n\n<p>Keep calling the <code>next()</code> method on the iterator returned from step 1. The return value from <code>next()</code> is assigned to <code>x</code> and the loop body is executed. If an exception <code>StopIteration</code> is raised from within <code>next()</code>, it means there are no more values in the iterator and the loop is exited.</p></li>\n</ol>\n\n<p>The truth is Python performs the above two steps anytime it wants to <em>loop over</em> the contents of an object - so it could be a for loop, but it could also be code like <code>otherlist.extend(mylist)</code> (where <code>otherlist</code> is a Python list).</p>\n\n<p>Here <code>mylist</code> is an <em>iterable</em> because it implements the iterator protocol. In a user defined class, you can implement the <code>__iter__()</code> method to make instances of your class iterable. This method should return an <em>iterator</em>. An iterator is an object with a <code>next()</code> method. It is possible to implement both <code>__iter__()</code> and <code>next()</code> on the same class, and have <code>__iter__()</code> return <code>self</code>. This will work for simple cases, but not when you want two iterators looping over the same object at the same time.</p>\n\n<p>So that's the iterator protocol, many objects implement this protocol:</p>\n\n<ol>\n<li>Built-in lists, dictionaries, tuples, sets, files.</li>\n<li>User defined classes that implement <code>__iter__()</code>.</li>\n<li>Generators.</li>\n</ol>\n\n<p>Note that a <code>for</code> loop doesn't know what kind of object it's dealing with - it just follows the iterator protocol, and is happy to get item after item as it calls <code>next()</code>. Built-in lists return their items one by one, dictionaries return the <em>keys</em> one by one, files return the <em>lines</em> one by one, etc. And generators return... well that's where <code>yield</code> comes in:</p>\n\n<pre><code>def f123():\n    yield 1\n    yield 2\n    yield 3\n\nfor item in f123():\n    print item\n</code></pre>\n\n<p>Instead of <code>yield</code> statements, if you had three <code>return</code> statements in <code>f123()</code> only the first would get executed, and the function would exit. But <code>f123()</code> is no ordinary function. When <code>f123()</code> is called, it <em>does not</em> return any of the values in the yield statements! It returns a generator object. Also, the function does not really exit - it goes into a suspended state. When the <code>for</code> loop tries to loop over the generator object, the function resumes from its suspended state, runs until the next <code>yield</code> statement and returns that as the next item. This happens until the function exits, at which point the generator raises <code>StopIteration</code>, and the loop exits. </p>\n\n<p>So the generator object is sort of like an adapter - at one end it exhibits the iterator protocol, by exposing <code>__iter__()</code> and <code>next()</code> methods to keep the <code>for</code> loop happy. At the other end however, it runs the function just enough to get the next value out of it, and puts it back in suspended mode.</p>\n\n<h2>Why Use Generators?</h2>\n\n<p>Usually you can write code that doesn't use generators but implements the same logic. One option is to use the temporary list 'trick' I mentioned before. That will not work in all cases, for e.g. if you have infinite loops, or it may make inefficient use of memory when you have a really long list. The other approach is to implement a new iterable class <code>SomethingIter</code> that keeps state in instance members and performs the next logical step in it's <code>next()</code> (or <code>__next__()</code> in Python 3) method. Depending on the logic, the code inside the <code>next()</code> method may end up looking very complex and be prone to bugs. Here generators provide a clean and easy solution.</p>\n",
            "question_id": 231767,
            "last_activity_date": 1406200516,
            "creation_date": 1224969750,
            "score": 813,
            "owner": {
                "link": "http://stackoverflow.com/users/28409/user28409",
                "display_name": "user28409",
                "reputation": 10704,
                "user_id": 28409,
                "user_type": "registered"
            },
            "is_accepted": false,
            "last_edit_date": 1406200516,
            "answer_id": 237028
        },
        {
            "body": "<p>here is simple example with result:</p>\n\n<pre><code>def isPrimeNumber(n):\n        print \"isPrimeNumber({}) call\".format(n)\n        if n==1:\n            return False\n        for x in range(2,n):\n            if n % x == 0:\n                return False\n        return True\n\n\ndef primes (n=1):\n        while(True):\n            print \"loop step ---------------- {}\".format(n)\n            if isPrimeNumber(n): yield n\n            n += 1\n\nfor n in primes():\n        if n&gt; 10:break\n        print \"wiriting result {}\".format(n)   \n</code></pre>\n\n<p>output :</p>\n\n<pre><code>loop step ---------------- 1\nisPrimeNumber(1) call\nloop step ---------------- 2\nisPrimeNumber(2) call\nloop step ---------------- 3\nisPrimeNumber(3) call\nwiriting result 3\nloop step ---------------- 4\nisPrimeNumber(4) call\nloop step ---------------- 5\nisPrimeNumber(5) call\nwiriting result 5\nloop step ---------------- 6\nisPrimeNumber(6) call\nloop step ---------------- 7\nisPrimeNumber(7) call\nwiriting result 7\nloop step ---------------- 8\nisPrimeNumber(8) call\nloop step ---------------- 9\nisPrimeNumber(9) call\nloop step ---------------- 10\nisPrimeNumber(10) call\nloop step ---------------- 11\nisPrimeNumber(11) call\n</code></pre>\n\n<p>I am not an python developer but it looks to me \"yield\"  holds the position of program flow and next time  loop start from \"yield\" position. Seems like waiting at that position and just before that returning value outside and next time continue to work.</p>\n\n<p>Seems to me interesting and nice ability :D </p>\n",
            "question_id": 231767,
            "last_activity_date": 1398451808,
            "creation_date": 1387544838,
            "score": 13,
            "owner": {
                "user_id": 1077381,
                "profile_image": "https://i.stack.imgur.com/p3GZL.png?s=128&g=1",
                "user_type": "registered",
                "reputation": 689,
                "link": "http://stackoverflow.com/users/1077381/engin-ozturk",
                "display_name": "Engin OZTURK"
            },
            "is_accepted": false,
            "last_edit_date": 1398451808,
            "answer_id": 20704301
        },
        {
            "body": "<p>While a lot of answers show why you'd use a <code>yield</code> to create a generator, there are more uses for <code>yield</code>.  It's quite easy to make a coroutine, which enables the passing of information between two blocks of code.  I won't repeat any of the fine examples that have already been given about using <code>yield</code> to create a generator.</p>\n\n<p>To help understand what a <code>yield</code> does in the following code, you can use your finger to trace the cycle through any code that has a <code>yield</code>.  Every time your finger hits the <code>yield</code>, you have to wait for a <code>next</code> or a <code>send</code> to be entered.  When a <code>next</code> is called, you trace through the code until you hit the <code>yield</code>\u2026 the code on the right of the <code>yield</code> is evaluated and returned to the caller\u2026 then you wait.  When <code>next</code> is called again, you perform another loop through the code.  However, you'll note that in a coroutine, <code>yield</code> can also be used with a <code>send</code>\u2026 which will send a value from the caller <em>into</em> the yielding function. If a <code>send</code> is given, then <code>yield</code> receives the value sent, and spits it out the left hand side\u2026 then the trace through the code progresses until you hit the <code>yield</code> again (returning the value at the end, as if <code>next</code> was called).</p>\n\n<p>For example:</p>\n\n<pre><code>&gt;&gt;&gt; def coroutine():\n...     i = -1\n...     while True:\n...         i += 1\n...         val = (yield i)\n...         print(\"Received %s\" % val)\n...\n&gt;&gt;&gt; sequence = coroutine()\n&gt;&gt;&gt; sequence.next()\n0\n&gt;&gt;&gt; sequence.next()\nReceived None\n1\n&gt;&gt;&gt; sequence.send('hello')\nReceived hello\n2\n&gt;&gt;&gt; sequence.close()\n</code></pre>\n",
            "question_id": 231767,
            "last_activity_date": 1391480855,
            "creation_date": 1391480855,
            "score": 26,
            "owner": {
                "user_id": 2379433,
                "profile_image": "https://www.gravatar.com/avatar/197d2417f199b0b6f951ee62e627a1d8?s=128&d=identicon&r=PG",
                "user_type": "registered",
                "reputation": 4986,
                "link": "http://stackoverflow.com/users/2379433/mike-mckerns",
                "display_name": "Mike McKerns"
            },
            "is_accepted": false,
            "answer_id": 21541902
        },
        {
            "body": "<p>From a programming viewpoint, the iterators are implemented as <strong>thunks</strong> </p>\n\n<p><a href=\"http://en.wikipedia.org/wiki/Thunk_(functional_programming)\">http://en.wikipedia.org/wiki/Thunk_(functional_programming)</a></p>\n\n<p>To implement thunks (also called anonymous functions), one uses messages sent to a closure object, which has a dispatcher, and the dispatcher answers to \"messages\".</p>\n\n<p><a href=\"http://en.wikipedia.org/wiki/Message_passing\">http://en.wikipedia.org/wiki/Message_passing</a></p>\n\n<p>\"<em>next</em>\" is a message sent to a closure, created by \"<em>iter</em>\" call.</p>\n",
            "question_id": 231767,
            "last_activity_date": 1377111685,
            "creation_date": 1377111685,
            "score": 10,
            "owner": {
                "user_id": 1419272,
                "profile_image": "https://www.gravatar.com/avatar/dcbff46aa5cd0a98d13d76595b3375f0?s=128&d=identicon&r=PG",
                "user_type": "registered",
                "reputation": 4104,
                "link": "http://stackoverflow.com/users/1419272/alinsoar",
                "accept_rate": 95,
                "display_name": "alinsoar"
            },
            "is_accepted": false,
            "answer_id": 18365578
        },
        {
            "body": "<p>Here is a mental image of what <code>yield</code> does.</p>\n\n<p>I like to think of a thread as having a stack (even if it's not implemented that way).</p>\n\n<p>When a normal function is called, it puts its local variables on the stack, does some computation, returns and clears the stack. The values of its local variables are never seen again.</p>\n\n<p>With a <code>yield</code> function, when it's called first, it similarly adds its local variables to the stack, but then takes its local variables to a special hideaway instead of clearing them, when it returns via <code>yield</code>. A possible place to put them would be somewhere in the heap.</p>\n\n<p>Note that it's not <em>the function</em> any more, it's a kind of an imprint or ghost of the function that the <code>for</code> loop is hanging onto.</p>\n\n<p>When it is called again, it retrieves its local variables from its special hideaway and puts them back on the stack and computes, then hides them again in the same way.</p>\n",
            "question_id": 231767,
            "last_activity_date": 1371227819,
            "creation_date": 1371227819,
            "score": 11,
            "owner": {
                "user_id": 1143274,
                "profile_image": "https://www.gravatar.com/avatar/bf11af111cab6e513d68e5e30762deb5?s=128&d=identicon&r=PG",
                "user_type": "registered",
                "reputation": 2972,
                "link": "http://stackoverflow.com/users/1143274/evgeni-sergeev",
                "accept_rate": 67,
                "display_name": "Evgeni Sergeev"
            },
            "is_accepted": false,
            "answer_id": 17113322
        },
        {
            "body": "<p>There's one extra thing to mention: a function that yields doesn't actually have to terminate. I've written code like this:</p>\n\n<pre><code>def fib():\n    last, cur = 0, 1\n    while True: \n        yield cur\n        last, cur = cur, last + cur\n</code></pre>\n\n<p>Then I can use it in other code like this:</p>\n\n<pre><code>for f in fib():\n    if some_condition: break\n    coolfuncs(f);\n</code></pre>\n\n<p>It really helps simplify some problems, and makes some things easier to work with. </p>\n",
            "question_id": 231767,
            "last_activity_date": 1366558934,
            "creation_date": 1224837848,
            "score": 75,
            "owner": {
                "user_id": 15055,
                "profile_image": "https://www.gravatar.com/avatar/7f71287b47b7189d11fe6d3fbc7ed2fe?s=128&d=identicon&r=PG",
                "user_type": "registered",
                "reputation": 76823,
                "link": "http://stackoverflow.com/users/15055/claudiu",
                "accept_rate": 84,
                "display_name": "Claudiu"
            },
            "is_accepted": false,
            "last_edit_date": 1366558934,
            "answer_id": 232853
        },
        {
            "body": "<p>I was going to post \"read page 19 of Beazley's 'Python: Essential Reference' for a quick description of generators\", but so many others have posted good descriptions already.</p>\n\n<p>Also, note that <code>yield</code> can be used in coroutines as the dual of their use in generator functions.  Although it isn't the same use as your code snippet, <code>(yield)</code> can be used as an expression in a function.  When a caller sends a value to the method using the <code>send()</code> method, then the coroutine will execute until the next <code>(yield)</code> statement is encountered.</p>\n\n<p>Generators and coroutines are a cool way to set up data-flow type applications.  I thought it would be worthwhile knowing about the other use of the <code>yield</code> statement in functions.</p>\n",
            "question_id": 231767,
            "last_activity_date": 1359337030,
            "creation_date": 1359337030,
            "score": 21,
            "owner": {
                "user_id": 479213,
                "profile_image": "https://www.gravatar.com/avatar/f8b6d939a3051f68b698f57eee1d1865?s=128&d=identicon&r=PG",
                "user_type": "registered",
                "reputation": 1052,
                "link": "http://stackoverflow.com/users/479213/johnzachary",
                "display_name": "johnzachary"
            },
            "is_accepted": false,
            "answer_id": 14554322
        },
        {
            "body": "<p>For those who prefer a minimal working example, meditate on this interactive <a href=\"http://en.wikipedia.org/wiki/Python_%28programming_language%29\">Python</a> session:</p>\n\n<pre><code>&gt;&gt;&gt; def f():\n...   yield 1\n...   yield 2\n...   yield 3\n... \n&gt;&gt;&gt; g = f()\n&gt;&gt;&gt; for i in g:\n...   print i\n... \n1\n2\n3\n&gt;&gt;&gt; for i in g:\n...   print i\n... \n&gt;&gt;&gt; # Note that this time nothing was printed\n</code></pre>\n",
            "question_id": 231767,
            "last_activity_date": 1359141552,
            "creation_date": 1358529917,
            "score": 48,
            "owner": {
                "user_id": 1531346,
                "profile_image": "https://www.gravatar.com/avatar/b221edf01a1f65198d7c6e6cfd2e4e2b?s=128&d=identicon&r=PG",
                "user_type": "registered",
                "reputation": 664,
                "link": "http://stackoverflow.com/users/1531346/daniel",
                "display_name": "Daniel"
            },
            "is_accepted": false,
            "last_edit_date": 1359141552,
            "answer_id": 14404292
        },
        {
            "body": "<p>Here are some <a href=\"https://github.com/dustingetz/sandbox/blob/master/etc/lazy.py\">Python examples of how to actually implement generators</a> as if Python did not provide syntactic sugar for them (or in a language without native syntax, like <a href=\"http://en.wikipedia.org/wiki/JavaScript\">JavaScript</a>). Snippets from that link is below.</p>\n\n<p><strong>As a Python generator:</strong></p>\n\n<pre><code>from itertools import islice\n\ndef fib_gen():\n    a, b = 1, 1\n    while True:\n        yield a\n        a, b = b, a + b\n\nassert [1, 1, 2, 3, 5] == list(islice(fib_gen(), 5))\n</code></pre>\n\n<p><strong>Using lexical closures instead of generators</strong></p>\n\n<pre><code>def ftake(fnext, last):\n    return [fnext() for _ in xrange(last)]\n\ndef fib_gen2():\n    #funky scope due to python2.x workaround\n    #for python 3.x use nonlocal\n    def _():\n        _.a, _.b = _.b, _.a + _.b\n        return _.a\n    _.a, _.b = 0, 1\n    return _\n\nassert [1,1,2,3,5] == ftake(fib_gen2(), 5)\n</code></pre>\n\n<p><strong>Using object closures instead of generators</strong> (because <a href=\"http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent\">ClosuresAndObjectsAreEquivalent</a>)</p>\n\n<pre><code>class fib_gen3:\n    def __init__(self):\n        self.a, self.b = 1, 1\n\n    def __call__(self):\n        r = self.a\n        self.a, self.b = self.b, self.a + self.b\n        return r\n\nassert [1,1,2,3,5] == ftake(fib_gen3(), 5)\n</code></pre>\n",
            "question_id": 231767,
            "last_activity_date": 1359141505,
            "creation_date": 1349296696,
            "score": 20,
            "owner": {
                "user_id": 20003,
                "profile_image": "https://www.gravatar.com/avatar/8c8dd2e41a62328fe8502000bc5a45ca?s=128&d=identicon&r=PG",
                "user_type": "registered",
                "reputation": 9764,
                "link": "http://stackoverflow.com/users/20003/dustin-getz",
                "accept_rate": 73,
                "display_name": "Dustin Getz"
            },
            "is_accepted": false,
            "last_edit_date": 1359141505,
            "answer_id": 12716515
        },
        {
            "body": "<p>Yield gives you a generator. </p>\n\n<pre><code>def get_odd_numbers(i):\n    return range(1, i, 2)\ndef yield_odd_numbers(i):\n    for x in range(1, i, 2):\n       yield x\nfoo = get_odd_numbers(10)\nbar = yield_odd_numbers(10)\nfoo\n[1, 3, 5, 7, 9]\nbar\n&lt;generator object yield_odd_numbers at 0x1029c6f50&gt;\nbar.next()\n1\nbar.next()\n3\nbar.next()\n5\n</code></pre>\n\n<p>As you can see, in the first case foo holds the entire list in memory at once. It's not a big deal for a list with 5 elements, but what if you want a list of 5 million? Not only is this a huge memory eater, it also costs a lot of time to build at the time that the function is called. In the second case, bar just gives you a generator. A generator is an iterable--which means you can use it in a for loop, etc, but each value can only be accessed once. All the values are also not stored in memory at the same time; the generator object \"remembers\" where it was in the looping the last time you called it--this way, if you're using an iterable to (say) count to 50 billion, you don't have to count to 50 billion all at once and store the 50 billion numbers to count through. Again, this is a pretty contrived example, you probably would use itertools if you really wanted to count to 50 billion. :)</p>\n\n<p>This is the most simple use case of generators. As you said, it can be used to write efficient permutations, using yield to push things up through the call stack instead of using some sort of stack variable. Generators can also be used for specialized tree traversal, and all manner of other things.</p>\n",
            "question_id": 231767,
            "last_activity_date": 1358318529,
            "creation_date": 1358318529,
            "score": 49,
            "owner": {
                "user_id": 1776798,
                "profile_image": "https://www.gravatar.com/avatar/41ac86025923cf752ae6aa44f9db9a32?s=128&d=identicon&r=PG",
                "user_type": "registered",
                "reputation": 499,
                "link": "http://stackoverflow.com/users/1776798/rbansal",
                "display_name": "RBansal"
            },
            "is_accepted": false,
            "answer_id": 14352675
        },
        {
            "body": "<p>Think of it this way:</p>\n\n<p>An iterator is just a fancy sounding term for an object that has a next() method.  So a yield-ed function ends up being something like this:</p>\n\n<p>Original version:</p>\n\n<pre><code>def some_function():\n    for i in xrange(4):\n        yield i\n\nfor i in some_function():\n    print i\n</code></pre>\n\n<p>This is basically what the python interpreter does with the above code:</p>\n\n<pre><code>class it:\n    def __init__(self):\n        #start at -1 so that we get 0 when we add 1 below.\n        self.count = -1\n    #the __iter__ method will be called once by the for loop.\n    #the rest of the magic happens on the object returned by this method.\n    #in this case it is the object itself.\n    def __iter__(self):\n        return self\n    #the next method will be called repeatedly by the for loop\n    #until it raises StopIteration.\n    def next(self):\n        self.count += 1\n        if self.count &lt; 4:\n            return self.count\n        else:\n            #a StopIteration exception is raised\n            #to signal that the iterator is done.\n            #This is caught implicitly by the for loop.\n            raise StopIteration \n\ndef some_func():\n    return it()\n\nfor i in some_func():\n    print i\n</code></pre>\n\n<p>For more insight as to what's happening behind the scenes, the for loop can be rewritten to this:</p>\n\n<pre><code>iterator = some_func()\ntry:\n    while 1:\n        print iterator.next()\nexcept StopIteration:\n    pass\n</code></pre>\n\n<p>Does that make more sense or just confuse you more?  :)</p>\n\n<p><strong>EDIT:</strong> I should note that this IS an oversimplification for illustrative purposes.  :)</p>\n\n<p><strong>EDIT 2:</strong> Forgot to throw the StopIteration exception</p>\n",
            "question_id": 231767,
            "last_activity_date": 1322211408,
            "creation_date": 1224800921,
            "score": 148,
            "owner": {
                "user_id": 2147,
                "profile_image": "https://www.gravatar.com/avatar/b8e26b9942e7193a4fe32c407aacfef5?s=128&d=identicon&r=PG",
                "user_type": "registered",
                "reputation": 68614,
                "link": "http://stackoverflow.com/users/2147/jason-baker",
                "accept_rate": 85,
                "display_name": "Jason Baker"
            },
            "is_accepted": false,
            "last_edit_date": 1322211408,
            "answer_id": 231801
        },
        {
            "body": "<p>I feel like I post a link to this presentation every day:  David M. Beazly's <a href=\"http://www.dabeaz.com/generators/\">Generator Tricks for Systems Programmers</a>.  If you're a Python programmer and you're not extremely familiar with generators, you should read this.  It's a very clear explanation of what generators are, how they work, what the yield statement does, and it answers the question \"Do you really want to mess around with this obscure language feature?\"  </p>\n\n<p>SPOILER ALERT.  The answer is:  Yes.  Yes, you do.</p>\n",
            "question_id": 231767,
            "last_activity_date": 1224835155,
            "creation_date": 1224835155,
            "score": 102,
            "owner": {
                "user_id": 19403,
                "profile_image": "https://www.gravatar.com/avatar/7554c591e3cc374e8623378d3385e092?s=128&d=identicon&r=PG",
                "user_type": "registered",
                "reputation": 51167,
                "link": "http://stackoverflow.com/users/19403/robert-rossney",
                "accept_rate": 59,
                "display_name": "Robert Rossney"
            },
            "is_accepted": false,
            "answer_id": 232791
        },
        {
            "body": "<p>An example in plain language. I will provide a correspondence between high-level human concepts to low-level python concepts.</p>\n\n<p>I want to operate on a sequence of numbers, but I don't want to bother my self with the creation of that sequence, I want only to focus on the operation I want to do. So, I do the following:</p>\n\n<ul>\n<li>I call you and tell you that I want a sequence of numbers which is produced in a specific way, and I let you know what the algorithm is.<br />\n<b>This step corresponds to <code>def</code>ining the generator function, i.e. the function containing a <code>yield</code>.</b></li>\n<li>Sometime later, I tell you, \"ok, get ready to tell me the sequence of numbers\".<br />\n<b>This step corresponds to calling the generator function which returns a generator object.</b> Note that you don't tell me any numbers yet, you just grab your paper and pencil.</li>\n<li>I ask you, \"tell me the next number\", and you tell me the first number; after that, you wait for me to ask you for the next number. It's your job to remember where you were, what numbers you have already said, what is the next number. I don't care about the details.<br />\n<b>This step corresponds to calling <code>.next()</code> on the generator object.</b></li>\n<li>\u2026 repeat previous step, until\u2026</li>\n<li>eventually, you might come to an end. You don't tell me a number, you just shout, \"hold your horses! I'm done! No more numbers!\"<br />\n<b>This step corresponds to the generator object ending its job, and raising a <code>StopIteration</code> exception</b> The generator function does not need to raise the exception, it's raised automatically when the function ends or issues a <code>return</code>.</li>\n</ul>\n\n<p>This is what a generator does (a function that contains a <code>yield</code>); it starts executing, pauses whenever it does a <code>yield</code>, and when asked for a <code>.next()</code> value it continues from the point it was last. It fits perfectly by design with the iterator protocol of python, which describes how to sequentially request for values.</p>\n\n<p>The most famous user of the iterator protocol is the <code>for</code> command in python. So, whenever you do a:</p>\n\n<pre><code>for item in sequence:\n</code></pre>\n\n<p>it doesn't matter if <code>sequence</code> is a list, a string, a dictionary or a generator <em>object</em> like described above; the result is the same: you read items off a sequence one by one.</p>\n\n<p>Note that <code>def</code>ining a function which contains a <code>yield</code> keyword is not the only way to create a generator; it's just the easiest way to create one.</p>\n\n<p>For more accurate information, read about <a href=\"http://docs.python.org/library/stdtypes.html#iterator-types\">iterator types</a>, the <a href=\"http://docs.python.org/reference/simple_stmts.html#yield\">yield statement</a> and <a href=\"http://docs.python.org/glossary.html#term-generator\">generators</a> in the Python documentation.</p>\n",
            "question_id": 231767,
            "last_activity_date": 1224808565,
            "creation_date": 1224808565,
            "score": 39,
            "owner": {
                "user_id": 6899,
                "profile_image": "https://www.gravatar.com/avatar/132aeb33251a1eddee3efc87633c0af1?s=128&d=identicon&r=PG",
                "user_type": "registered",
                "reputation": 39934,
                "link": "http://stackoverflow.com/users/6899/tzot",
                "accept_rate": 90,
                "display_name": "tzot"
            },
            "is_accepted": false,
            "answer_id": 232111
        },
        {
            "body": "<p>It's returning a generator. I'm not particularly familiar with Python, but I believe it's the same kind of thing as <a href=\"http://csharpindepth.com/Articles/Chapter11/StreamingAndIterators.aspx\">C#'s iterator blocks</a> if you're familiar with those.</p>\n\n<p>There's an <a href=\"http://www.ibm.com/developerworks/library/l-pycon.html\">IBM article</a> which explains it reasonably well (for Python) as far as I can see.</p>\n\n<p>The key idea is that the compiler/interpreter/whatever does some trickery so that as far as the caller is concerned, they can keep calling next() and it will keep returning values - <em>as if the generator method was paused</em>. Now obviously you can't really \"pause\" a method, so the compiler builds a state machine for you to remember where you currently are and what the local variables etc look like. This is much easier than writing an iterator yourself.</p>\n",
            "question_id": 231767,
            "last_activity_date": 1224800766,
            "creation_date": 1224800766,
            "score": 40,
            "owner": {
                "user_id": 22656,
                "profile_image": "https://www.gravatar.com/avatar/6d8ebb117e8d83d74ea95fbdd0f87e13?s=128&d=identicon&r=PG",
                "user_type": "registered",
                "reputation": 816639,
                "link": "http://stackoverflow.com/users/22656/jon-skeet",
                "accept_rate": 87,
                "display_name": "Jon Skeet"
            },
            "is_accepted": false,
            "answer_id": 231788
        }
    ],
    "quota_max": 300,
    "quota_remaining": 49
}
has_more
